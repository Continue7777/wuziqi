[TOC]

### 思路

先不要参考网上的资料，把自己的思路先尝试。没有解决的问题再去查看。需要锻炼自己的工程能力和思考能力，不要老懒得想问题。



### 待实现

在baseline的基础之上，利用统计的方法来查看最后胜的可能棋形。

整理非可视化代码，整出所有进攻的最后一子棋形，然后退化的方式给权重。防守拿规则来做。给出一个版本。



### 问题

现在的虽然很蠢可以写出更好的逻辑，但是并没有解决从baseline训练出更好能力的解决方案，现在是逻辑可以有很明显提升的时候，拿就用最有把握的思路去解题。

下一步骤建立在现在特征完善且参数给定的情况，希望能够自己训练出各个参数下的权重。

3 - 1 隔一个空构成的棋现在貌似是有bug的。

对于相同决策的返回处理不够优化。

​	-> 如果我已经100了，后续没有使用最小路径胜利。胜利偏向路径越小越好

​	-> 偏向我方路数最多越好

​	-> 终上所述，处理路径长短和整个局势的判断。（高分端的密集度）

​	-> 解决现在倾向于左上角的错误选择。需要修改get_logit_score（需要返回更多的信息，最高分的个数，交错情况。）

### 领任务

2017.12.10 修改特征逻辑、给定经验权重，并与之前的算法对抗看结果。 预计1个小时 2.5h了，bug还没调完。

2017.12.23 解决往后看步数的问题，思路如下：如果存在一条路径为：顺着这条路往下找，每一步敌人都必须防守，且最后我方能赢，走这条路。





### 2017.12.23

#### 感性需求：

向后探索n步，增强棋艺。根据现有对棋势的判断即可，在棋势的整体认知精度上并不会有提升。

#### 细化技术方案：

（以下两个问题都是性能和精度问题）

1. n的步数可调整，越多资源消耗远大，保证3步性能可靠。
2. 需要明确的几个问题
   1. 是否进行剪枝，根据中间过程的评分。  —— 暂时仅拿是否获胜。
   2. 对手的策略空间的确认问题、以及我方策略空间的确认。此处需要明确是所有可行空间还是高分空间  ——这里影响的也仅仅是效率问题，一个阈值就能搞定。
   3. 我方策略空间：第一个子尽可能大，后续均为现在最优判断。因为现在还不考虑最优解。不放过一定能赢的机会。

#### 流程图：

if 第一个点 -> 返回中心点

​		    ->	给棋盘设置虚拟棋谱，动态规划，单步走取最大的思路。return 最大对应的step1

#### 性能考虑：

估算每次30个step1,让对手做最可能发展的棋，不要走飞。O(n)。

#### 考虑工程实现方案：

1.需要想一种办法来估算分数，这里的评估和之前的冲突。

2.复制一份棋谱，qipu_predict={},每次在这张棋谱上判断。

#### 接口设计：

best_step_n(self)：—> x,y 判断n步探索模式下最优的坐标

->找到所有一次探索点

​	-> 可行点的判断条件：之前的打分0,1有一个>0即可

​	-> 如果没有点合适的话，切换成best_step

->找到该点路下的最优分数 _get_score(x,y) -> score 

​	->不同路径下返回的max是有区别的

​	->max(my_score,enemy_score)

->记录最大的score,并return x,y

​	-> 防止敌方最大化的时候，应该想办法优化我方棋局。

​	-> 敌方n步内最小

_get_score(x,y)->score： ————————————————ok
->新建立棋谱，添加x,y

->根据best_step1新增后续，来回5个回合，直到找到最优方案。

​	-> 返回的分数的含义需要直接指示我方棋子，所以和之前的分数不能混合max(my_score,enemy_score)，这个可以但是，my_score，enemy_score 的步数必须一样。如果我比敌方高，则取最高，如果都低则取最低，如果相等还是取自己。（这里博弈的思想就出来了）

​	



### 2017.12.24

1. 花30分钟把博弈的算法的得分再理一下。  ok
2. 1h写代码+debug   15:30 1步ok    ——————————1步存在的问题，全是活3的时候，变成了随机。活2和双三的交界一定会死。多看一步就 可以解决。——————我方存在很多96的时候，也会随便下。
3. 看博客里面怎么处理博弈树，以及其优化。