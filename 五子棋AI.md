[TOC]

### 思路

先不要参考网上的资料，把自己的思路先尝试。没有解决的问题再去查看。需要锻炼自己的工程能力和思考能力，不要老懒得想问题。



### 待实现

在baseline的基础之上，利用统计的方法来查看最后胜的可能棋形。

整理非可视化代码，整出所有进攻的最后一子棋形，然后退化的方式给权重。防守拿规则来做。给出一个版本。



### 问题

现在的虽然很蠢可以写出更好的逻辑，但是并没有解决从baseline训练出更好能力的解决方案，现在是逻辑可以有很明显提升的时候，拿就用最有把握的思路去解题。

下一步骤建立在现在特征完善且参数给定的情况，希望能够自己训练出各个参数下的权重。

3 - 1 隔一个空构成的棋现在貌似是有bug的。



### 领任务

2017.12.10 修改特征逻辑、给定经验权重，并与之前的算法对抗看结果。 预计1个小时 2.5h了，bug还没调完。

2017.12.23 解决往后看步数的问题，思路如下：如果存在一条路径为：顺着这条路往下找，每一步敌人都必须防守，且最后我方能赢，走这条路。



### 2017.12.23

#### 感性需求：

向后探索n步，增强棋艺。根据现有对棋势的判断即可，在棋势的整体认知精度上并不会有提升。

#### 细化技术方案：

（以下两个问题都是性能和精度问题）

1. n的步数可调整，越多资源消耗远大，保证3步性能可靠。
2. 需要明确的几个问题
   1. 是否进行剪枝，根据中间过程的评分。  —— 暂时仅拿是否获胜。
   2. 对手的策略空间的确认问题、以及我方策略空间的确认。此处需要明确是所有可行空间还是高分空间  ——这里影响的也仅仅是效率问题，一个阈值就能搞定。
   3. 我方策略空间：第一个子尽可能大，后续均为现在最优判断。因为现在还不考虑最优解。不放过一定能赢的机会。

#### 流程图：

if 第一个点 -> 返回中心点

​		    ->	给棋盘设置虚拟棋谱，动态规划，单步走取最大的思路。return 最大对应的step1

#### 性能考虑：

估算每次30个step1,让对手做最可能发展的棋，不要走飞。O(n)。

#### 考虑工程实现方案：

1.需要想一种办法来估算分数，这里的评估和之前的冲突。

2.复制一份棋谱，qipu_predict={},每次在这张棋谱上判断。

#### 接口设计：

best_step_n(self)：—> x,y 判断n步探索模式下最优的坐标

->找到所有一次探索点

->找到该点路下的最优分数 _get_score(x,y) -> score 

->记录最大的score,并return x,y

_get_score(x,y)->score：
->新建立棋谱，添加x,y

->根据best_step1新增后续，来回5个回合，直到找到最优方案。



